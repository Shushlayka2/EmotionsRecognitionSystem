void ConvolutionalLayer::correct() {
	
	//mock
	float* filters_host = new float[filters_device.depth * filters_device.matrixes_size];
	for (int i = 0; i < filters_device.depth; i++)
		for (int j = 0; j < filters_device.rows_count; j++)
			for (int l = 0; l < filters_device.cols_count; l++)
				filters_host[i * filters_device.matrixes_size + j * filters_device.cols_count + l] = i * filters_device.matrixes_size + j * filters_device.cols_count + l;
	cudaFree(filters_device.data);
	cudaMallocPitch((void**)&filters_device.data, &filters_device.pitch, filters_device.matrixes_size * sizeof(float), filters_device.depth);
	cudaMemcpy2D(filters_device.data, filters_device.pitch, filters_host, filters_device.matrixes_size * sizeof(float), filters_device.matrixes_size * sizeof(float), filters_device.depth, cudaMemcpyHostToDevice);
	free(filters_host);

	gradients_device.cols_count = 3;  gradients_device.rows_count = 3; gradients_device.matrixes_size = 9; gradients_device.depth = 3;
	float* gradients_host = new float[gradients_device.depth * gradients_device.matrixes_size];
	for (int i = 0; i < gradients_device.depth; i++)
		for (int j = 0; j < gradients_device.rows_count; j++)
			for (int l = 0; l < gradients_device.cols_count; l++)
				gradients_host[i * gradients_device.matrixes_size + j * gradients_device.cols_count + l] = i * gradients_device.matrixes_size + j * gradients_device.cols_count + l;

	cudaFree(gradients_device.data);
	cudaMallocPitch((void**)&gradients_device.data, &gradients_device.pitch, gradients_device.matrixes_size * sizeof(float), gradients_device.depth);
	cudaMemcpy2D(gradients_device.data, gradients_device.pitch, gradients_host, gradients_device.matrixes_size * sizeof(float), gradients_device.matrixes_size * sizeof(float), gradients_device.depth, cudaMemcpyHostToDevice);
	free(gradients_host);

	outputs_devices.cols_count = 3;  outputs_devices.rows_count = 3; outputs_devices.matrixes_size = 9; outputs_devices.depth = 3;
	float* outputs_host = new float[outputs_devices.depth * outputs_devices.matrixes_size];
	for (int i = 0; i < outputs_devices.depth; i++)
	{
		for (int j = 0; j < outputs_devices.rows_count; j++)
		{
			for (int l = 0; l < outputs_devices.cols_count; l++)
			{
				outputs_host[i * outputs_devices.matrixes_size + j * outputs_devices.cols_count + l] = i * outputs_devices.matrixes_size + j * outputs_devices.cols_count + l;
				if (l % 2 == 0)
					outputs_host[i * outputs_devices.matrixes_size + j * outputs_devices.cols_count + l] *= -1;
			}
		}
	}
	cudaFree(outputs_devices.data);
	cudaMallocPitch((void**)&outputs_devices.data, &outputs_devices.pitch, outputs_devices.matrixes_size * sizeof(float), outputs_devices.depth);
	cudaMemcpy2D(outputs_devices.data, outputs_devices.pitch, outputs_host, outputs_devices.matrixes_size * sizeof(float), outputs_devices.matrixes_size * sizeof(float), outputs_devices.depth, cudaMemcpyHostToDevice);
	free(outputs_host);

	inputs_device.cols_count = 5; inputs_device.rows_count = 5; inputs_device.matrixes_size = 25; inputs_device.depth = 1;
	float* inputs_host = new float[inputs_device.depth * inputs_device.matrixes_size];
	for (int i = 0; i < inputs_device.depth; i++)
		for (int j = 0; j < inputs_device.rows_count; j++)
			for (int l = 0; l < inputs_device.cols_count; l++)
				inputs_host[i * inputs_device.matrixes_size + j * inputs_device.cols_count + l] = i * inputs_device.matrixes_size + j * inputs_device.cols_count + l;
	cudaFree(inputs_device.data);
	cudaMallocPitch((void**)&inputs_device.data, &inputs_device.pitch, inputs_device.matrixes_size * sizeof(float), inputs_device.depth);
	cudaMemcpy2D(inputs_device.data, inputs_device.pitch, inputs_host, inputs_device.matrixes_size * sizeof(float), inputs_device.matrixes_size * sizeof(float), inputs_device.depth, cudaMemcpyHostToDevice);
	free(inputs_host);

	cudaBindTexture2D(0, FiltersRef, gradients_device.data, FiltersRef.channelDesc, gradients_device.matrixes_size, gradients_device.depth, gradients_device.pitch);
	cudaBindTexture2D(0, MatrixesRef, inputs_device.data, MatrixesRef.channelDesc, inputs_device.matrixes_size, inputs_device.depth, inputs_device.pitch);
	cudaBindTexture2D(0, OutputsRef, outputs_devices.data, OutputsRef.channelDesc, outputs_devices.matrixes_size, outputs_devices.depth, outputs_devices.pitch);
	
	dim3 threadsPerBlock = dim3(32, 32, 1);
	dim3 blocksPerGrid = dim3(gradients_device.cols_count / 32 + (gradients_device.cols_count % 32 == 0 ? 0 : 1),
		gradients_device.rows_count / 32 + (gradients_device.rows_count % 32 == 0 ? 0 : 1), filters_device.depth);
	
	cuda_correct_filters << <blocksPerGrid, threadsPerBlock >> > (filters_device.data, filters_device.cols_count, filters_device.rows_count, filters_device.pitch, gradients_device.cols_count, gradients_device.rows_count, inputs_device.rows_count, inputs_device.depth, filters_device.depth);
	cudaDeviceSynchronize();
	cudacall(cudaGetLastError());

	//assert
	filters_host = new float[filters_device.matrixes_size * filters_device.depth];
	cudaMemcpy2D(filters_host, filters_device.matrixes_size * sizeof(float), filters_device.data, filters_device.pitch, filters_device.matrixes_size * sizeof(float), filters_device.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < filters_device.depth; i++)
	{
		for (int j = 0; j < filters_device.rows_count; j++)
		{
			for (int l = 0; l < filters_device.cols_count; l++)
			{
				printf("%f ", filters_host[i * filters_device.matrixes_size + j * filters_device.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
	free(filters_host);

	threadsPerBlock = dim3(256);
	blocksPerGrid = dim3(gradients_device.depth / 256 + (gradients_device.depth % 256 == 0 ? 0 : 1));
	
	cuda_correct_biases << <blocksPerGrid, threadsPerBlock >> > (biases_device, gradients_device.depth, gradients_device.cols_count, gradients_device.rows_count);
	cudaDeviceSynchronize();
	cudacall(cudaGetLastError());

	cudaUnbindTexture(FiltersRef);
	cudaUnbindTexture(MatrixesRef);
	cudaUnbindTexture(OutputsRef);
}