FullConnectedLayer::backward

//test
	float* gradients_host = new float[out_size];
	float* prev_gr_host = new float[in_size];
	float* weights_host = new float[out_size * in_size];
	cudaMemcpy(gradients_host, gradients_device, out_size * sizeof(float), cudaMemcpyDeviceToHost);
	cudaMemcpy(weights_host, weights_device, out_size * in_size * sizeof(float), cudaMemcpyDeviceToHost);

	for (int i = 0; i < out_size; i++)
	{
		printf("%f ", gradients_host[i]);
	}
	printf("\n\n");

	for (int i = 0; i < out_size; i++)
	{
		for (int j = 0; j < in_size; j++)
		{
			printf("%f ", weights_host[i * in_size + j]);
		}
		printf("\n");
	}
	printf("\n");
	
	m_v_multiplication(weights_device, gradients_device, prev_layer_gradients, handle, CUBLAS_OP_N);
	
	//test
	cudaMemcpy(prev_gr_host, prev_layer_gradients, in_size * sizeof(float), cudaMemcpyDeviceToHost);

	for (int i = 0; i < in_size; i++)
	{
		printf("%f ", prev_gr_host[i]);
	}
	printf("\n");
	free(gradients_host);
	free(prev_gr_host);
	free(weights_host);
	
PoolingLayer::backward

dim3 threadsPerBlock = dim3(BLOCK_SIZE, BLOCK_SIZE, 1);
	dim3 blocksPerGrid = dim3(gradients_device.cols_count / BLOCK_SIZE + (gradients_device.cols_count % BLOCK_SIZE == 0 ? 0 : 1), gradients_device.rows_count / BLOCK_SIZE + (gradients_device.rows_count % BLOCK_SIZE == 0 ? 0 : 1), gradients_device.depth);
	cudaBindTexture2D(0, GradientMatrixesRef, gradients_device.data, GradientMatrixesRef.channelDesc, gradients_device.matrixes_size, gradients_device.depth, gradients_device.pitch);

	//test
	printf("\nPooling layer:\n\n");
	float* pool_gr_host = new float[gradients_device.matrixes_size * gradients_device.depth];
	cudaMemcpy2D(pool_gr_host, gradients_device.matrixes_size * sizeof(float), gradients_device.data, gradients_device.pitch,
		gradients_device.matrixes_size * sizeof(float), gradients_device.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < gradients_device.depth; i++)
	{
		for (int j = 0; j < gradients_device.rows_count; j++)
		{
			for (int l = 0; l < gradients_device.cols_count; l++)
			{
				printf("%f ", pool_gr_host[i * gradients_device.matrixes_size + j * gradients_device.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");

	float* conv_gr_host = new float[prev_gradient_matrixes.matrixes_size * prev_gradient_matrixes.depth];
	cudaMemcpy2D(conv_gr_host, prev_gradient_matrixes.matrixes_size * sizeof(float), prev_gradient_matrixes.data, prev_gradient_matrixes.pitch,
		prev_gradient_matrixes.matrixes_size * sizeof(float), prev_gradient_matrixes.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < prev_gradient_matrixes.depth; i++)
	{
		for (int j = 0; j < prev_gradient_matrixes.rows_count; j++)
		{
			for (int l = 0; l < prev_gradient_matrixes.cols_count; l++)
			{
				printf("%f ", conv_gr_host[i * prev_gradient_matrixes.matrixes_size + j * prev_gradient_matrixes.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");

	cuda_generate_gradients << <blocksPerGrid, threadsPerBlock >> > (prev_gradient_matrixes.data, prev_gradient_matrixes.pitch, prev_gradient_matrixes.cols_count, prev_gradient_matrixes.rows_count, gradients_device.cols_count, filter_size);
	cudaDeviceSynchronize();
	cudacall(cudaGetLastError());

	//test
	cudaMemcpy2D(conv_gr_host, prev_gradient_matrixes.matrixes_size * sizeof(float), prev_gradient_matrixes.data, prev_gradient_matrixes.pitch,
		prev_gradient_matrixes.matrixes_size * sizeof(float), prev_gradient_matrixes.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < prev_gradient_matrixes.depth; i++)
	{
		for (int j = 0; j < prev_gradient_matrixes.rows_count; j++)
		{
			for (int l = 0; l < prev_gradient_matrixes.cols_count; l++)
			{
				printf("%f ", conv_gr_host[i * prev_gradient_matrixes.matrixes_size + j * prev_gradient_matrixes.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
	free(conv_gr_host);

	cudaUnbindTexture(InputMatrixesRef);
	
ConvolutionalLayer::backward

//test
	float* filters_host = new float[filters_device.matrixes_size * filters_device.depth];
	cudaMemcpy2D(filters_host, filters_device.matrixes_size * sizeof(float), filters_device.data, filters_device.pitch, filters_device.matrixes_size * sizeof(float), filters_device.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < filters_device.depth; i++)
	{
		for (int j = 0; j < filters_device.rows_count; j++)
		{
			for (int l = 0; l < filters_device.cols_count; l++)
			{
				printf("%f ", filters_host[i * filters_device.matrixes_size + j * filters_device.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");

	cuda_revert_filters << <blocksPerGrid, threadsPerBlock >> > (filters_device.data, reverted_filters_device, filters_device.pitch, reverted_filters_pitch, filters_device.cols_count, filters_device.rows_count, filters_device.depth);
	cudaDeviceSynchronize();
	cudacall(cudaGetLastError());

	//test
	float* reverted_filters_host = new float[filters_device.matrixes_size * filters_device.depth];
	cudaMemcpy2D(reverted_filters_host, filters_device.matrixes_size * sizeof(float), reverted_filters_device, reverted_filters_pitch, filters_device.matrixes_size * sizeof(float), filters_device.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < filters_device.depth; i++)
	{
		for (int j = 0; j < filters_device.rows_count; j++)
		{
			for (int l = 0; l < filters_device.cols_count; l++)
			{
				printf("%f ", reverted_filters_host[i * filters_device.matrixes_size + j * filters_device.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
	free(reverted_filters_host);
	
	//test
	float* conv_gr_host = new float[gradients_device.matrixes_size * gradients_device.depth];
	cudaMemcpy2D(conv_gr_host, gradients_device.matrixes_size * sizeof(float), gradients_device.data, gradients_device.pitch,
		gradients_device.matrixes_size * sizeof(float), gradients_device.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < gradients_device.depth; i++)
	{
		for (int j = 0; j < gradients_device.rows_count; j++)
		{
			for (int l = 0; l < gradients_device.cols_count; l++)
			{
				printf("%f ", conv_gr_host[i * gradients_device.matrixes_size + j * gradients_device.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
	free(conv_gr_host);
	
	//test
	float* padded_conv_gr_host = new float[padded_gradients_matrixes_size * gradients_device.depth];
	cudaMemcpy2D(padded_conv_gr_host, padded_gradients_matrixes_size * sizeof(float), padded_gradients_device, padded_gradients_pitch,
		padded_gradients_matrixes_size * sizeof(float), gradients_device.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < gradients_device.depth; i++)
	{
		for (int j = 0; j < padded_gradients_matrixes_rows; j++)
		{
			for (int l = 0; l < padded_gradients_matrixes_cols; l++)
			{
				printf("%f ", padded_conv_gr_host[i * padded_gradients_matrixes_size + j * padded_gradients_matrixes_cols + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
	free(padded_conv_gr_host);
	
	//test
	float* prev_gr_host = new float[prev_gradient_matrixes.matrixes_size * prev_gradient_matrixes.depth];
	cudaMemcpy2D(prev_gr_host, prev_gradient_matrixes.matrixes_size * sizeof(float), prev_gradient_matrixes.data, prev_gradient_matrixes.pitch,
		prev_gradient_matrixes.matrixes_size * sizeof(float), prev_gradient_matrixes.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < prev_gradient_matrixes.depth; i++)
	{
		for (int j = 0; j < prev_gradient_matrixes.rows_count; j++)
		{
			for (int l = 0; l < prev_gradient_matrixes.cols_count; l++)
			{
				printf("%f ", prev_gr_host[i * prev_gradient_matrixes.matrixes_size + j * prev_gradient_matrixes.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
	free(prev_gr_host);

ConvolutionalLayer::correct

	//test
	printf("\nConvolution layer:\n\n");
	float* conv_gr_host = new float[gradients_device.matrixes_size * gradients_device.depth];
	cudaMemcpy2D(conv_gr_host, gradients_device.matrixes_size * sizeof(float), gradients_device.data, gradients_device.pitch,
		gradients_device.matrixes_size * sizeof(float), gradients_device.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < gradients_device.depth; i++)
	{
		for (int j = 0; j < gradients_device.rows_count; j++)
		{
			for (int l = 0; l < gradients_device.cols_count; l++)
			{
				printf("%f ", conv_gr_host[i * gradients_device.matrixes_size + j * gradients_device.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
	free(conv_gr_host);

	float* inputs_host = new float[inputs_device.matrixes_size * inputs_device.depth];
	cudaMemcpy2D(inputs_host, inputs_device.matrixes_size * sizeof(float), inputs_device.data, inputs_device.pitch,
		inputs_device.matrixes_size * sizeof(float), inputs_device.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < inputs_device.depth; i++)
	{
		for (int j = 0; j < inputs_device.rows_count; j++)
		{
			for (int l = 0; l < inputs_device.cols_count; l++)
			{
				printf("%f ", inputs_host[i * inputs_device.matrixes_size + j * inputs_device.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
	free(inputs_host);

	float* filters_host = new float[filters_device.matrixes_size * filters_device.depth];
	cudaMemcpy2D(filters_host, filters_device.matrixes_size * sizeof(float), filters_device.data, filters_device.pitch, filters_device.matrixes_size * sizeof(float), filters_device.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < filters_device.depth; i++)
	{
		for (int j = 0; j < filters_device.rows_count; j++)
		{
			for (int l = 0; l < filters_device.cols_count; l++)
			{
				printf("%f ", filters_host[i * filters_device.matrixes_size + j * filters_device.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");

	float* outputs_host = new float[outputs_devices.matrixes_size * outputs_devices.depth];
	cudaMemcpy2D(outputs_host, outputs_devices.matrixes_size * sizeof(float), outputs_devices.data, outputs_devices.pitch, outputs_devices.matrixes_size * sizeof(float), outputs_devices.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < outputs_devices.depth; i++)
	{
		for (int j = 0; j < outputs_devices.rows_count; j++)
		{
			for (int l = 0; l < outputs_devices.cols_count; l++)
			{
				printf("%f ", outputs_host[i * outputs_devices.matrixes_size + j * outputs_devices.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
	free(outputs_host);


	filters_host = new float[filters_device.matrixes_size * filters_device.depth];
	cudaMemcpy2D(filters_host, filters_device.matrixes_size * sizeof(float), filters_device.data, filters_device.pitch, filters_device.matrixes_size * sizeof(float), filters_device.depth, cudaMemcpyDeviceToHost);
	for (int i = 0; i < filters_device.depth; i++)
	{
		for (int j = 0; j < filters_device.rows_count; j++)
		{
			for (int l = 0; l < filters_device.cols_count; l++)
			{
				printf("%f ", filters_host[i * filters_device.matrixes_size + j * filters_device.cols_count + l]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
	free(filters_host);
	
ConvolutionalLayer::correct (Mocks)

	//test
	float *Gradients_host = new float[27], *Inputs_host = new float[25], *Filters_host = new float[27], *Outputs_host = new float[27];
	inputs_device.cols_count = 5;  inputs_device.rows_count = 5; inputs_device.matrixes_size = 25; inputs_device.depth = 1;
	for (int i = 0; i < inputs_device.depth; i++)
	{
		for (int j = 0; j < inputs_device.rows_count; j++)
		{
			for (int l = 0; l < inputs_device.cols_count; l++)
			{
				Inputs_host[i * inputs_device.matrixes_size + j * inputs_device.cols_count + l] = i * inputs_device.matrixes_size + j * inputs_device.cols_count + l;
			}
		}
	}
	cudaFree(inputs_device.data);
	cudaMallocPitch((void**)&inputs_device.data, &inputs_device.pitch, inputs_device.matrixes_size * sizeof(float), inputs_device.depth);
	cudaMemcpy2D(inputs_device.data, inputs_device.pitch, Inputs_host, inputs_device.matrixes_size * sizeof(float), inputs_device.matrixes_size * sizeof(float), inputs_device.depth, cudaMemcpyHostToDevice);
	free(Inputs_host);

	gradients_device.cols_count = 3;  gradients_device.rows_count = 3; gradients_device.matrixes_size = 9; gradients_device.depth = 3;
	for (int i = 0; i < gradients_device.depth; i++)
	{
		for (int j = 0; j < gradients_device.rows_count; j++)
		{
			for (int l = 0; l < gradients_device.cols_count; l++)
			{
				Gradients_host[i * gradients_device.matrixes_size + j * gradients_device.cols_count + l] = i * gradients_device.matrixes_size + j * gradients_device.cols_count + l;
			}
		}
	}
	cudaFree(gradients_device.data);
	cudaMallocPitch((void**)&gradients_device.data, &gradients_device.pitch, gradients_device.matrixes_size * sizeof(float), gradients_device.depth);
	cudaMemcpy2D(gradients_device.data, gradients_device.pitch, Gradients_host, gradients_device.matrixes_size * sizeof(float), gradients_device.matrixes_size * sizeof(float), gradients_device.depth, cudaMemcpyHostToDevice);
	free(Gradients_host);

	filters_device.cols_count = 3;  filters_device.rows_count = 3; filters_device.matrixes_size = 9; filters_device.depth = 3;
	for (int i = 0; i < filters_device.depth; i++)
	{
		for (int j = 0; j < filters_device.rows_count; j++)
		{
			for (int l = 0; l < filters_device.cols_count; l++)
			{
				Filters_host[i * filters_device.matrixes_size + j * filters_device.cols_count + l] = 0;
			}
		}
	}
	cudaFree(filters_device.data);
	cudaMallocPitch((void**)&filters_device.data, &filters_device.pitch, filters_device.matrixes_size * sizeof(float), filters_device.depth);
	cudaMemcpy2D(filters_device.data, filters_device.pitch, Filters_host, filters_device.matrixes_size * sizeof(float), filters_device.matrixes_size * sizeof(float), filters_device.depth, cudaMemcpyHostToDevice);
	free(Filters_host);

	outputs_devices.cols_count = 3;  outputs_devices.rows_count = 3; outputs_devices.matrixes_size = 9; outputs_devices.depth = 3;
	for (int i = 0; i < outputs_devices.depth; i++)
	{
		for (int j = 0; j < outputs_devices.rows_count; j++)
		{
			for (int l = 0; l < outputs_devices.cols_count; l++)
			{
				Outputs_host[i * outputs_devices.matrixes_size + j * outputs_devices.cols_count + l] = i * outputs_devices.matrixes_size + j * outputs_devices.cols_count + l;
				if (-1 * (l % 2) == 0)
					Outputs_host[i * outputs_devices.matrixes_size + j * outputs_devices.cols_count + l] *= -1;
			}
		}
	}
	cudaFree(outputs_devices.data);
	cudaMallocPitch((void**)&outputs_devices.data, &outputs_devices.pitch, outputs_devices.matrixes_size * sizeof(float), outputs_devices.depth);
	cudaMemcpy2D(outputs_devices.data, outputs_devices.pitch, Outputs_host, outputs_devices.matrixes_size * sizeof(float), outputs_devices.matrixes_size * sizeof(float), outputs_devices.depth, cudaMemcpyHostToDevice);
	free(Outputs_host);
	
	printf("r_pos = %u gr_num = %u gr_pos = %u m_pos = %u l = %u: %f : out = %f inp = %f gr = %f\n", result_position, gr_num, gr_position, matrix_position, l, result_start[result_position], tex2D(OutputsRef, gr_position, gr_num), tex2D(MatrixesRef, matrix_position, l), tex2D(FiltersRef, gr_position, gr_num));
	